//! This module defines the `Event` struct and its associated `EventBuilder` for creating new events.
//! It also provides the `EventData` trait, which must be implemented by any data structure used as an
//! event's payload, and error types for event creation and conversion.

use chrono::{DateTime, Utc};
use serde::Serialize;
use uuid::Uuid;

/// Event definition
#[derive(Debug, Clone, PartialEq)]
pub struct Event<D>
where
    D: EventData,
{
    /// Event ID
    pub id: Uuid,

    /// The id of the entity this event aggregates to
    pub stream_id: Uuid,

    /// The version number of the envent. Used to check for sync issues
    pub stream_version: u64,

    /// Event type
    ///
    /// The type of this event in PascalCase, like `OrganisationCreated` or `StudyCurated`
    pub event_type: String,

    /// The ID of the creator of this event
    pub actor_id: Option<Uuid>,

    /// Purger subject ID
    ///
    /// Will be `None` if event is not purged
    pub purger_id: Option<Uuid>,

    /// Event data
    ///
    /// If the event has been purged, this will be `None` for security/compliance reasons - the data
    /// must be deleted from both the event log and the aggregate tables. Check the `purged_at` or
    /// `purger_id` fields to check the purge status.
    pub data: Option<D>,

    /// The time at which this event was created
    pub created_at: DateTime<Utc>,

    /// The time at which this event was purged, if any
    pub purged_at: Option<DateTime<Utc>>,

    /// Global sequence number assigned by the event store.
    ///
    /// This is a monotonically increasing sequence number across all events in the store,
    /// used for reliable event delivery, checkpointing, and catch-up processing.
    /// It is `None` until the event is persisted to the event store.
    ///
    /// # Design Note
    ///
    /// A future improvement could introduce a `StoredEvent<D>` type that guarantees
    /// `global_sequence` is always present for events read from the store. This would
    /// eliminate the need for `.unwrap_or(0)` calls and make the type system enforce
    /// the invariant that persisted events always have a sequence number.
    pub global_sequence: Option<u64>,

    /// The ID of the event that directly caused this event to be produced.
    ///
    /// `None` for events triggered by direct user commands (no prior event in the chain).
    /// `Some(event_id)` when this event was produced as a consequence of another event
    /// (e.g., via a saga reacting to an event and dispatching a command).
    pub causation_id: Option<Uuid>,

    /// A shared identifier tying together all events in a causal tree.
    ///
    /// All events originating from the same user action share the same `correlation_id`.
    /// Auto-generated by `Aggregate::handle()` if not provided on the command.
    /// `None` for events that predate causation tracking.
    pub correlation_id: Option<Uuid>,
}

impl<D> Event<D>
where
    D: EventData,
{
    /// Creates a new `EventBuilder` instance.
    pub fn builder() -> EventBuilder<D> {
        EventBuilder::new()
    }

    /// Converts `self` into an `EventBuilder`.
    pub fn into_builder(self) -> EventBuilder<D> {
        self.into()
    }

    /// Transforms this event to a subset event type.
    ///
    /// This method converts the event data from type `D` to a subset type `ED` by
    /// cloning the entire event data before conversion. For better performance,
    /// prefer [`to_subset_event_ref`](Self::to_subset_event_ref) which only clones
    /// the matched variant's fields.
    ///
    /// # Type Parameters
    ///
    /// * `ED` - The target event data type. Must implement `TryFrom<D>`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// // ApplicationEvent is the superset, UserEvent is a subset
    /// let app_event: Event<ApplicationEvent> = /* ... */;
    /// let user_event: Event<UserEvent> = app_event.to_subset_event()?;
    /// ```
    pub fn to_subset_event<ED>(&self) -> Result<Event<ED>, ED::Error>
    where
        ED: EventData + TryFrom<D>,
        ED::Error: Send + Sync,
    {
        let data = self
            .data
            .as_ref()
            .map(|d| ED::try_from(d.clone()))
            .transpose()?;
        Ok(Event {
            id: self.id,
            stream_id: self.stream_id,
            stream_version: self.stream_version,
            event_type: self.event_type.clone(),
            actor_id: self.actor_id,
            purger_id: self.purger_id,
            data,
            created_at: self.created_at,
            purged_at: self.purged_at,
            global_sequence: self.global_sequence,
            correlation_id: self.correlation_id,
            causation_id: self.causation_id,
        })
    }

    /// Transforms this event to a subset event type using reference-based conversion.
    ///
    /// This is an optimized version of [`to_subset_event`](Self::to_subset_event) that
    /// only clones the matched variant's fields rather than the entire enum. Use this
    /// when you have implemented `TryFrom<&D>` for your event type (which is automatically
    /// generated by the `#[subset_enum]` derive macro).
    ///
    /// # Type Parameters
    ///
    /// * `ED` - The target event data type. Must implement `TryFrom<&D>`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// // ApplicationEvent is the superset, UserEvent is a subset  
    /// let app_event: Event<ApplicationEvent> = /* ... */;
    /// let user_event: Event<UserEvent> = app_event.to_subset_event_ref()?;
    /// ```
    pub fn to_subset_event_ref<ED>(&self) -> Result<Event<ED>, EnumConversionError>
    where
        ED: EventData + for<'a> TryFrom<&'a D, Error = EnumConversionError>,
    {
        let data = self.data.as_ref().map(|d| ED::try_from(d)).transpose()?;
        Ok(Event {
            id: self.id,
            stream_id: self.stream_id,
            stream_version: self.stream_version,
            global_sequence: self.global_sequence,
            event_type: self.event_type.clone(),
            actor_id: self.actor_id,
            purger_id: self.purger_id,
            data,
            created_at: self.created_at,
            purged_at: self.purged_at,
            correlation_id: self.correlation_id,
            causation_id: self.causation_id,
        })
    }

    /// Transforms this event
    pub fn to_superset_event<ED>(&self) -> Event<ED>
    where
        ED: EventData,
        D: Into<ED>,
    {
        let data = self.data.as_ref().map(|d| d.clone().into());
        Event {
            id: self.id,
            stream_id: self.stream_id,
            stream_version: self.stream_version,
            event_type: self.event_type.clone(),
            actor_id: self.actor_id,
            purger_id: self.purger_id,
            data,
            created_at: self.created_at,
            purged_at: self.purged_at,
            global_sequence: self.global_sequence,
            correlation_id: self.correlation_id,
            causation_id: self.causation_id,
        }
    }
}

impl<D> From<Event<D>> for EventBuilder<D>
where
    D: EventData,
{
    fn from(event: Event<D>) -> Self {
        Self {
            id: Some(event.id),
            stream_id: Some(event.stream_id),
            stream_version: Some(event.stream_version),
            event_type: Some(event.event_type),
            actor_id: event.actor_id,
            purger_id: event.purger_id,
            data: event.data,
            created_at: Some(event.created_at),
            purged_at: event.purged_at,
            global_sequence: event.global_sequence,
            correlation_id: event.correlation_id,
            causation_id: event.causation_id,
        }
    }
}

impl<D> From<D> for EventBuilder<D>
where
    D: EventData,
{
    fn from(data: D) -> Self {
        Self {
            data: Some(data.clone()),
            event_type: Some(data.event_type().to_string()),
            ..EventBuilder::new()
        }
    }
}

/// Builder for `Event`
#[derive(Debug)]
pub struct EventBuilder<D>
where
    D: EventData,
{
    /// The event ID.
    pub id: Option<Uuid>,
    /// The stream ID
    pub stream_id: Option<Uuid>,
    /// The sequence number of the event.
    pub stream_version: Option<u64>,
    /// The event type.
    pub event_type: Option<String>,
    /// The ID of the creator of this event.
    pub actor_id: Option<Uuid>,
    /// The ID of the purger of this event.
    pub purger_id: Option<Uuid>,
    /// The event data.
    pub data: Option<D>,
    /// The time at which this event was created.
    pub created_at: Option<DateTime<Utc>>,
    /// The time at which this event was purged, if any.
    pub purged_at: Option<DateTime<Utc>>,
    /// Global sequence number assigned by the event store.
    pub global_sequence: Option<u64>,
    /// The correlation ID to link related events together.
    pub correlation_id: Option<Uuid>,
    /// The causation ID pointing to the event that caused this one.
    pub causation_id: Option<Uuid>,
}

impl<D> Default for EventBuilder<D>
where
    D: EventData,
{
    fn default() -> Self {
        Self::new()
    }
}

impl<D> EventBuilder<D>
where
    D: EventData,
{
    /// Creates a new `EventBuilder` instance with all fields set to `None`.
    pub fn new() -> Self {
        EventBuilder {
            id: None,
            stream_id: None,
            stream_version: None,
            event_type: None,
            actor_id: None,
            purger_id: None,
            data: None,
            created_at: None,
            purged_at: None,
            global_sequence: None,
            correlation_id: None,
            causation_id: None,
        }
    }

    /// Sets the ID for the event.
    pub fn id(mut self, id: Uuid) -> Self {
        self.id = Some(id);
        self
    }

    /// Sets the stream ID for the event.
    pub fn stream_id(mut self, stream_id: Uuid) -> Self {
        self.stream_id = Some(stream_id);
        self
    }

    /// Sets the sequence number for the event.
    pub fn stream_version(mut self, sequence_number: u64) -> Self {
        self.stream_version = Some(sequence_number);
        self
    }

    /// Sets the event type for the event.
    pub fn event_type(mut self, event_type: String) -> Self {
        self.event_type = Some(event_type);
        self
    }

    /// Sets the actor ID for the event.
    pub fn actor_id(mut self, actor_id: Uuid) -> Self {
        self.actor_id = Some(actor_id);
        self
    }

    /// Sets the purger ID for the event.
    pub fn purger_id(mut self, purger_id: Uuid) -> Self {
        self.purger_id = Some(purger_id);
        self
    }

    /// Sets the data payload for the event.
    pub fn data<P: EventData>(self, data: Option<P>) -> EventBuilder<P> {
        EventBuilder {
            id: self.id,
            stream_id: self.stream_id,
            stream_version: self.stream_version,
            event_type: self.event_type,
            actor_id: self.actor_id,
            purger_id: self.purger_id,
            data,
            created_at: self.created_at,
            purged_at: self.purged_at,
            global_sequence: self.global_sequence,
            correlation_id: self.correlation_id,
            causation_id: self.causation_id,
        }
    }

    /// Sets the creation timestamp for the event.
    pub fn created_at(mut self, created_at: DateTime<Utc>) -> Self {
        self.created_at = Some(created_at);
        self
    }

    /// Sets the purged timestamp for the event.
    pub fn purged_at(mut self, purged_at: DateTime<Utc>) -> Self {
        self.purged_at = Some(purged_at);
        self
    }

    /// Sets the global sequence number for the event.
    ///
    /// This is typically set by the event store when persisting the event,
    /// not by application code.
    pub fn global_sequence(mut self, global_sequence: u64) -> Self {
        self.global_sequence = Some(global_sequence);
        self
    }

    /// Sets the correlation ID for the event.
    ///
    /// The correlation ID ties together all events in a causal tree originating
    /// from the same user action.
    pub fn correlation_id(mut self, correlation_id: Uuid) -> Self {
        self.correlation_id = Some(correlation_id);
        self
    }

    /// Sets the causation ID for the event.
    ///
    /// The causation ID points to the specific event that directly caused this
    /// event to be produced.
    pub fn causation_id(mut self, causation_id: Uuid) -> Self {
        self.causation_id = Some(causation_id);
        self
    }

    /// Builds the `Event` from the `EventBuilder`.
    ///
    /// # Errors
    ///
    /// Returns an error if `id`, `sequence_number`, `event_type`, or `created_at` are not set.
    pub fn build(self) -> Result<Event<D>, EventBuilderError> {
        Ok(Event {
            id: self.id.unwrap_or_else(Uuid::new_v4),
            stream_id: self.stream_id.ok_or(EventBuilderError::StreamIdMissing)?,
            stream_version: self.stream_version.unwrap_or(0),
            event_type: self.event_type.ok_or(EventBuilderError::EventTypeMissing)?,
            actor_id: self.actor_id,
            purger_id: self.purger_id,
            data: self.data,
            created_at: self.created_at.unwrap_or(Utc::now()),
            purged_at: self.purged_at,
            global_sequence: self.global_sequence,
            correlation_id: self.correlation_id,
            causation_id: self.causation_id,
        })
    }
}

/// An event's data payload
pub trait EventData: Serialize + serde::de::DeserializeOwned + Sized + Clone + Send {
    /// Get the event type/identifier in PascalCase like `UserCreated` or `PasswordChanged`
    fn event_type(&self) -> &'static str;

    /// Converts `self` into an `EventBuilder`.
    fn into_builder(self) -> EventBuilder<Self>
    where
        Self: Sized,
    {
        self.into()
    }
}

/// Error returned when an event cannot be converted from one type to another.
#[derive(Debug, thiserror::Error)]
#[error("Can't convert enum variant {0} into subset-enum {1}")]
pub struct EnumConversionError(String, String);

impl EnumConversionError {
    /// Creates a new `EnumConversionError`.
    ///
    /// # Arguments
    ///
    /// * `origina_enum_variant` - The name of the original enum variant that could not be converted.
    /// * `subenum` - The name of the sub-enum that the conversion was attempted into.
    pub fn new(origina_enum_variant: String, subenum: String) -> Self {
        EnumConversionError(origina_enum_variant, subenum)
    }
}

/// Errors that can occur when building an `Event`.
#[derive(Debug, thiserror::Error)]
pub enum EventBuilderError {
    /// The event ID is missing.
    #[error("Event Stream ID is required")]
    StreamIdMissing,
    /// The stream version is missing.
    #[error("Event Stream version is required")]
    StreamVersionMissing,
    /// The event type is missing.
    #[error("Event type is required")]
    EventTypeMissing,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
    enum TestEventData {
        TestEvent { value: String },
    }

    impl EventData for TestEventData {
        fn event_type(&self) -> &'static str {
            match self {
                TestEventData::TestEvent { .. } => "TestEvent",
            }
        }
    }

    #[test]
    fn event_builder_with_global_sequence() {
        let event = Event::<TestEventData>::builder()
            .stream_id(Uuid::new_v4())
            .event_type("Test".to_string())
            .global_sequence(42)
            .build()
            .unwrap();
        assert_eq!(event.global_sequence, Some(42));
    }

    #[test]
    fn event_builder_without_global_sequence_defaults_to_none() {
        let event = Event::<TestEventData>::builder()
            .stream_id(Uuid::new_v4())
            .event_type("Test".to_string())
            .build()
            .unwrap();
        assert_eq!(event.global_sequence, None);
    }

    #[test]
    fn event_into_builder_preserves_global_sequence() {
        let stream_id = Uuid::new_v4();
        let original = Event {
            id: Uuid::new_v4(),
            stream_id,
            stream_version: 1,
            event_type: "Test".to_string(),
            actor_id: None,
            purger_id: None,
            data: Some(TestEventData::TestEvent {
                value: "test".to_string(),
            }),
            created_at: Utc::now(),
            purged_at: None,
            global_sequence: Some(100),
            causation_id: None,
            correlation_id: None,
        };
        let rebuilt = original.into_builder().build().unwrap();
        assert_eq!(rebuilt.global_sequence, Some(100));
    }

    #[test]
    fn to_subset_event_preserves_global_sequence() {
        let stream_id = Uuid::new_v4();
        let original: Event<TestEventData> = Event {
            id: Uuid::new_v4(),
            stream_id,
            stream_version: 1,
            event_type: "Test".to_string(),
            actor_id: None,
            purger_id: None,
            data: Some(TestEventData::TestEvent {
                value: "test".to_string(),
            }),
            created_at: Utc::now(),
            purged_at: None,
            global_sequence: Some(50),
            causation_id: None,
            correlation_id: None,
        };
        // TestEventData -> TestEventData conversion (identity)
        let subset: Event<TestEventData> = original.to_subset_event().unwrap();
        assert_eq!(subset.global_sequence, Some(50));
    }

    #[test]
    fn to_superset_event_preserves_global_sequence() {
        let stream_id = Uuid::new_v4();
        let original: Event<TestEventData> = Event {
            id: Uuid::new_v4(),
            stream_id,
            stream_version: 1,
            event_type: "Test".to_string(),
            actor_id: None,
            purger_id: None,
            data: Some(TestEventData::TestEvent {
                value: "test".to_string(),
            }),
            created_at: Utc::now(),
            purged_at: None,
            global_sequence: Some(75),
            causation_id: None,
            correlation_id: None,
        };
        // TestEventData -> TestEventData conversion (identity)
        let superset: Event<TestEventData> = original.to_superset_event();
        assert_eq!(superset.global_sequence, Some(75));
    }

    #[test]
    fn data_builder_method_preserves_global_sequence() {
        let builder = Event::<TestEventData>::builder()
            .stream_id(Uuid::new_v4())
            .event_type("Test".to_string())
            .global_sequence(123);

        let new_builder = builder.data(Some(TestEventData::TestEvent {
            value: "test".to_string(),
        }));

        let event = new_builder.build().unwrap();
        assert_eq!(event.global_sequence, Some(123));
    }

    #[test]
    fn event_builder_with_causation_fields() {
        let correlation_id = Uuid::new_v4();
        let causation_id = Uuid::new_v4();

        let event = Event::<TestEventData>::builder()
            .stream_id(Uuid::new_v4())
            .event_type("Test".to_string())
            .correlation_id(correlation_id)
            .causation_id(causation_id)
            .build()
            .unwrap();

        assert_eq!(event.correlation_id, Some(correlation_id));
        assert_eq!(event.causation_id, Some(causation_id));
    }

    #[test]
    fn event_builder_without_causation_defaults_to_none() {
        let event = Event::<TestEventData>::builder()
            .stream_id(Uuid::new_v4())
            .event_type("Test".to_string())
            .build()
            .unwrap();

        assert_eq!(event.correlation_id, None);
        assert_eq!(event.causation_id, None);
    }

    #[test]
    fn event_into_builder_preserves_causation() {
        let correlation_id = Uuid::new_v4();
        let causation_id = Uuid::new_v4();
        let stream_id = Uuid::new_v4();

        let original = Event {
            id: Uuid::new_v4(),
            stream_id,
            stream_version: 1,
            event_type: "Test".to_string(),
            actor_id: None,
            purger_id: None,
            data: Some(TestEventData::TestEvent {
                value: "test".to_string(),
            }),
            created_at: Utc::now(),
            purged_at: None,
            global_sequence: Some(100),
            correlation_id: Some(correlation_id),
            causation_id: Some(causation_id),
        };

        let rebuilt = original.into_builder().build().unwrap();

        assert_eq!(rebuilt.correlation_id, Some(correlation_id));
        assert_eq!(rebuilt.causation_id, Some(causation_id));
    }

    #[test]
    fn to_subset_event_preserves_causation() {
        let correlation_id = Uuid::new_v4();
        let causation_id = Uuid::new_v4();
        let stream_id = Uuid::new_v4();

        let original: Event<TestEventData> = Event {
            id: Uuid::new_v4(),
            stream_id,
            stream_version: 1,
            event_type: "Test".to_string(),
            actor_id: None,
            purger_id: None,
            data: Some(TestEventData::TestEvent {
                value: "test".to_string(),
            }),
            created_at: Utc::now(),
            purged_at: None,
            global_sequence: Some(50),
            correlation_id: Some(correlation_id),
            causation_id: Some(causation_id),
        };

        let subset: Event<TestEventData> = original.to_subset_event().unwrap();

        assert_eq!(subset.correlation_id, Some(correlation_id));
        assert_eq!(subset.causation_id, Some(causation_id));
    }

    #[test]
    fn to_subset_event_ref_preserves_causation() {
        use crate::event::EnumConversionError;

        // Create a simple subset relationship for testing
        #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
        enum SubsetEventData {
            TestEvent { value: String },
        }

        impl EventData for SubsetEventData {
            fn event_type(&self) -> &'static str {
                "TestEvent"
            }
        }

        // Manual implementation of TryFrom<&TestEventData> for SubsetEventData
        impl TryFrom<&TestEventData> for SubsetEventData {
            type Error = EnumConversionError;

            fn try_from(value: &TestEventData) -> Result<Self, Self::Error> {
                match value {
                    TestEventData::TestEvent { value } => Ok(SubsetEventData::TestEvent {
                        value: value.clone(),
                    }),
                }
            }
        }

        let correlation_id = Uuid::new_v4();
        let causation_id = Uuid::new_v4();
        let stream_id = Uuid::new_v4();

        let original: Event<TestEventData> = Event {
            id: Uuid::new_v4(),
            stream_id,
            stream_version: 1,
            event_type: "Test".to_string(),
            actor_id: None,
            purger_id: None,
            data: Some(TestEventData::TestEvent {
                value: "test".to_string(),
            }),
            created_at: Utc::now(),
            purged_at: None,
            global_sequence: Some(75),
            correlation_id: Some(correlation_id),
            causation_id: Some(causation_id),
        };

        let subset: Event<SubsetEventData> = original.to_subset_event_ref().unwrap();

        assert_eq!(subset.correlation_id, Some(correlation_id));
        assert_eq!(subset.causation_id, Some(causation_id));
    }

    #[test]
    fn to_superset_event_preserves_causation() {
        let correlation_id = Uuid::new_v4();
        let causation_id = Uuid::new_v4();
        let stream_id = Uuid::new_v4();

        let original: Event<TestEventData> = Event {
            id: Uuid::new_v4(),
            stream_id,
            stream_version: 1,
            event_type: "Test".to_string(),
            actor_id: None,
            purger_id: None,
            data: Some(TestEventData::TestEvent {
                value: "test".to_string(),
            }),
            created_at: Utc::now(),
            purged_at: None,
            global_sequence: Some(75),
            correlation_id: Some(correlation_id),
            causation_id: Some(causation_id),
        };

        let superset: Event<TestEventData> = original.to_superset_event();

        assert_eq!(superset.correlation_id, Some(correlation_id));
        assert_eq!(superset.causation_id, Some(causation_id));
    }

    #[test]
    fn data_builder_method_preserves_causation() {
        let correlation_id = Uuid::new_v4();
        let causation_id = Uuid::new_v4();

        let builder = Event::<TestEventData>::builder()
            .stream_id(Uuid::new_v4())
            .event_type("Test".to_string())
            .correlation_id(correlation_id)
            .causation_id(causation_id)
            .global_sequence(123);

        let new_builder = builder.data(Some(TestEventData::TestEvent {
            value: "test".to_string(),
        }));

        let event = new_builder.build().unwrap();

        assert_eq!(event.correlation_id, Some(correlation_id));
        assert_eq!(event.causation_id, Some(causation_id));
        assert_eq!(event.global_sequence, Some(123));
    }
}
