//! Saga definition

use crate::event::{EnumConversionError, Event, EventData};
use crate::prelude::{EventObserver, StateStoreBackend};
use async_trait::async_trait;
use std::sync::Arc;
use uuid::Uuid;

/// Defines the errors that can happen when handling an event in a saga.
///
/// Note: Conversion failures (when converting from a superset event to the saga's
/// subset event type) are intentionally ignored in `process_event()`. This is expected
/// behavior since sagas only handle events from their subset.
#[derive(Debug, thiserror::Error)]
pub enum HandleEventError<S, E> {
    /// An error raised while handling the event
    #[error("Error while handling event: {0}")]
    Saga(S),
    /// An error raised by the state store
    #[error("Error while storing state: {0}")]
    State(E),
}

/// `Saga` is a trait that defines the interface for a saga in an event-sourced system.
/// A saga is a long-running business process that is coordinated by a series of local transactions.
///
/// # Event Observer Integration
///
/// To subscribe a saga to an event bus, wrap it in [`SagaHandler`] which provides the
/// [`EventObserver`] implementation. This is necessary because [`Projection`](crate::projection::Projection)
/// already has a blanket `EventObserver` impl, and Rust doesn't allow multiple blanket impls.
///
/// # Example
///
/// ```ignore
/// use epoch_core::saga::SagaHandler;
///
/// #[async_trait]
/// impl Saga<ApplicationEvent> for MySaga {
///     type State = MySagaState;
///     type StateStore = MyStateStore;
///     type SagaError = MySagaError;
///     type EventType = MySagaEvent;
///
///     fn get_state_store(&self) -> Self::StateStore { /* ... */ }
///
///     async fn handle_event(
///         &self,
///         state: Self::State,
///         event: &Event<Self::EventType>,  // Note: takes reference
///     ) -> Result<Option<Self::State>, Self::SagaError> {
///         match &event.data {
///             MySagaEvent::SomethingHappened { .. } => { /* ... */ }
///         }
///     }
/// }
///
/// // Wrap in SagaHandler to subscribe to the event bus
/// let saga = MySaga::new();
/// event_bus.subscribe(SagaHandler::new(saga)).await?;
/// ```
#[async_trait]
pub trait Saga<ED>
where
    ED: EventData + Send + Sync + 'static,
{
    /// The type of the state of the saga. This acts as a state machine. It should be defined as an
    /// enum
    type State: Send + Sync + Default;
    /// The type of `StateStorage` used by this `Saga`.
    type StateStore: StateStoreBackend<Self::State> + Send + Sync;
    /// The type of errors that may occur when handling events in this `Saga`.
    type SagaError: std::error::Error + Send + Sync + 'static;
    /// The type of event used by this saga.
    ///
    /// Must implement `TryFrom<&ED, Error = EnumConversionError>` for efficient
    /// reference-based conversion. This is automatically generated by the `#[subset_enum]` macro.
    type EventType: EventData + for<'a> TryFrom<&'a ED, Error = EnumConversionError>;

    /// Returns a unique identifier for this saga subscriber.
    ///
    /// This ID is used for checkpoint tracking, multi-instance coordination, and dead letter
    /// queue association. Follow the naming convention: `"saga:<name>"`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// fn subscriber_id(&self) -> &str {
    ///     "saga:order-fulfillment"
    /// }
    /// ```
    fn subscriber_id(&self) -> &str;

    /// Returns the `StateStorage` implementation for this `Saga`.
    fn get_state_store(&self) -> Self::StateStore;

    /// Handles an incoming event, potentially producing and dispatching commands.
    ///
    /// The event is passed by reference to avoid unnecessary cloning. If you need to
    /// retain the event data, you can clone the specific fields you need.
    async fn handle_event(
        &self,
        state: Self::State,
        event: &Event<Self::EventType>,
    ) -> Result<Option<Self::State>, Self::SagaError>;

    /// Returns the ID of the saga from the given event.
    fn get_id_from_event(&self, event: &Event<Self::EventType>) -> Uuid {
        event.stream_id
    }

    /// Processes an incoming event, applies it to the saga, and persists the resulting state.
    ///
    /// This method is called by the blanket [`EventObserver`] implementation. It handles:
    /// 1. Converting the event to the saga's event type via [`Event::to_subset_event`]
    /// 2. Loading the current saga state from the state store
    /// 3. Calling [`Saga::handle_event`] with the state and event
    /// 4. Persisting or deleting the resulting state
    ///
    /// The event is passed by reference to avoid unnecessary cloning.
    async fn process_event(
        &self,
        event: &Event<ED>,
    ) -> Result<
        (),
        HandleEventError<
            Self::SagaError,
            <Self::StateStore as StateStoreBackend<Self::State>>::Error,
        >,
    > {
        if let Ok(event) = event.to_subset_event_ref::<Self::EventType>() {
            let id = self.get_id_from_event(&event);
            let mut storage = self.get_state_store();
            let state = storage
                .get_state(id)
                .await
                .map_err(HandleEventError::State)?
                .unwrap_or_default();

            let state = self
                .handle_event(state, &event)
                .await
                .map_err(HandleEventError::Saga)?;

            if let Some(state) = state {
                storage
                    .persist_state(id, state)
                    .await
                    .map_err(HandleEventError::State)?;
            } else {
                storage
                    .delete_state(id)
                    .await
                    .map_err(HandleEventError::State)?;
            }
        }
        Ok(())
    }
}

/// A wrapper type that provides an [`EventObserver`] implementation for [`Saga`] types.
///
/// Since Rust doesn't allow multiple blanket implementations of the same trait, and
/// [`Projection`](crate::projection::Projection) already has a blanket `EventObserver` impl,
/// sagas must be wrapped in `SagaHandler` to be subscribed to an event bus.
///
/// # Example
///
/// ```ignore
/// use epoch_core::saga::SagaHandler;
///
/// let saga = MySaga::new();
/// let handler = SagaHandler::new(saga);
/// event_bus.subscribe(handler).await?;
/// ```
pub struct SagaHandler<S>(pub S);

impl<S> SagaHandler<S> {
    /// Creates a new `SagaHandler` wrapping the given saga.
    pub fn new(saga: S) -> Self {
        Self(saga)
    }

    /// Returns a reference to the inner saga.
    pub fn inner(&self) -> &S {
        &self.0
    }

    /// Consumes the handler and returns the inner saga.
    pub fn into_inner(self) -> S {
        self.0
    }
}

#[async_trait]
impl<ED, S> EventObserver<ED> for SagaHandler<S>
where
    ED: EventData + Send + Sync + 'static,
    S: Saga<ED> + Send + Sync,
{
    fn subscriber_id(&self) -> &str {
        Saga::subscriber_id(&self.0)
    }

    async fn on_event(
        &self,
        event: Arc<Event<ED>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        self.0.process_event(&event).await?;
        Ok(())
    }
}
