//! This module defines traits for `Projection`
//! A `Projection` is a read-model built from a stream of events.

use std::pin::Pin;
use std::sync::Arc;

use crate::{
    event::{EnumConversionError, Event, EventData},
    prelude::{EventObserver, EventStream, RefEventStream},
    state_store::StateStoreBackend,
};
use async_trait::async_trait;
use tokio_stream::StreamExt;
use uuid::Uuid;

/// `ProjectionState` represents the current state of a projection.
/// It encapsulates the current data derived from a sequence of events.
pub trait ProjectionState {
    /// Returns the unique identifier of the projection instance. This ID is used to retrieve and persist the projection's state and events.
    fn get_id(&self) -> Uuid;
}

/// `ApplyAndStoreError` enumerates the possible errors that can occur during the application
/// and storage of a projection's state.
///
/// Note: Conversion failures (when converting from a superset event to the projection's
/// subset event type) are intentionally ignored in `apply_and_store()`. This is expected
/// behavior since projections only handle events from their subset.
#[derive(Debug, thiserror::Error)]
pub enum ApplyAndStoreError<E, S> {
    /// Represents an error that occurred while applying an event to the projection.
    #[error("Event application error: {0}")]
    Event(E),
    /// Represents an error that occurred while persisting the projection's state to storage.
    #[error("Error persisting state: {0}")]
    State(S),
}

/// The Errors that can arise during a rehydration
#[derive(Debug, thiserror::Error)]
pub enum ReHydrateError<E, S, ES> {
    /// Event applicatione erors
    #[error("Event application error: {0}")]
    Application(E),
    /// Event transformation errors
    #[error("Error transforming event: {0}")]
    Subset(S),
    /// Event stream reading errors
    #[error("Error reading from event stream: {0}")]
    EventStream(ES),
}

/// `Projection` is a trait that defines the interface for a read-model that can be built
/// from a stream of events.
#[async_trait]
pub trait Projection<ED>
where
    ED: EventData + Send + Sync + 'static,
{
    /// The type of the state that this `Projection` manages.
    type State: ProjectionState + Send + Sync + Clone;
    /// The type of `StateStorage` used by this `Projection`.
    type StateStore: StateStoreBackend<Self::State> + Send + Sync;
    /// The type of event used by this projection.
    ///
    /// Must implement `TryFrom<&ED, Error = EnumConversionError>` for efficient
    /// reference-based conversion. This is automatically generated by the `#[subset_enum]` macro.
    type EventType: EventData + for<'a> TryFrom<&'a ED, Error = EnumConversionError>;
    /// The type of errors that may occur when applying events
    type ProjectionError: std::error::Error + Send + Sync + 'static;

    /// Returns a unique identifier for this projection subscriber.
    ///
    /// This ID is used for checkpoint tracking, multi-instance coordination, and dead letter
    /// queue association. Follow the naming convention: `"projection:<name>"`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// fn subscriber_id(&self) -> &str {
    ///     "projection:user-profile"
    /// }
    /// ```
    fn subscriber_id(&self) -> &str;

    /// Applies an event to the aggregate.
    /// If None is returned it will result in the state being deleted from storage.
    /// If `Some(state)` is returned, the state will be persisted instead of deleted.
    fn apply(
        &self,
        _state: Option<Self::State>,
        _event: &Event<Self::EventType>,
    ) -> Result<Option<Self::State>, Self::ProjectionError>;

    /// Returns the `StateStorage` implementation for this `Projection`.
    fn get_state_store(&self) -> Self::StateStore;

    /// Reconstructs the projection's state from an event stream.
    async fn re_hydrate<'a, E>(
        &self,
        mut state: Option<Self::State>,
        mut event_stream: Pin<Box<dyn EventStream<ED, E> + Send + 'a>>,
    ) -> Result<
        Option<Self::State>,
        ReHydrateError<<Self as Projection<ED>>::ProjectionError, EnumConversionError, E>,
    > {
        while let Some(event) = event_stream.next().await {
            let event = event.map_err(ReHydrateError::EventStream)?;
            let event = event
                .to_subset_event_ref()
                .map_err(ReHydrateError::Subset)?;
            state = self
                .apply(state, &event)
                .map_err(ReHydrateError::Application)?;
        }

        Ok(state)
    }

    /// Reconstructs the projection's state from a reference-based event stream.
    ///
    /// This is an optimized version of [`re_hydrate`](Self::re_hydrate) that accepts
    /// a stream of event references rather than owned events. This avoids cloning
    /// events when re-hydrating from a local slice (e.g., in [`Aggregate::handle`]).
    ///
    /// # Type Parameters
    ///
    /// * `'a` - The lifetime of the event references in the stream
    /// * `E` - The error type that can be returned by the stream
    ///
    /// # Arguments
    ///
    /// * `state` - The initial state to start re-hydration from, or `None` for a fresh projection
    /// * `event_stream` - A pinned reference-based event stream
    ///
    /// # Returns
    ///
    /// The re-hydrated state after applying all events from the stream, or an error if
    /// event application or stream reading fails.
    async fn re_hydrate_from_refs<'a, E>(
        &self,
        mut state: Option<Self::State>,
        mut event_stream: Pin<Box<dyn RefEventStream<'a, ED, E> + Send + 'a>>,
    ) -> Result<
        Option<Self::State>,
        ReHydrateError<<Self as Projection<ED>>::ProjectionError, EnumConversionError, E>,
    >
    where
        E: 'a,
    {
        while let Some(event) = event_stream.next().await {
            let event = event.map_err(ReHydrateError::EventStream)?;
            let event = event
                .to_subset_event_ref()
                .map_err(ReHydrateError::Subset)?;
            state = self
                .apply(state, &event)
                .map_err(ReHydrateError::Application)?;
        }

        Ok(state)
    }

    /// Applies an event to the projection. This method dispatches the event to the appropriate
    /// `apply_create`, `apply_update`, or `apply_delete` method based on the event type.
    ///
    /// Takes a reference to the event to avoid unnecessary cloning.
    async fn apply_and_store(
        &self,
        event: &Event<ED>,
    ) -> Result<
        (),
        ApplyAndStoreError<
            Self::ProjectionError,
            <Self::StateStore as StateStoreBackend<Self::State>>::Error,
        >,
    > {
        if let Ok(event) = event.to_subset_event_ref::<Self::EventType>() {
            let id = self.get_id_from_event(&event);
            let mut storage = self.get_state_store();
            let state = storage
                .get_state(id)
                .await
                .map_err(ApplyAndStoreError::State)?;
            if let Some(new_state) = self
                .apply(state, &event)
                .map_err(ApplyAndStoreError::Event)?
            {
                log::debug!("Persisting state for projection: {:?}", id);
                storage
                    .persist_state(id, new_state)
                    .await
                    .map_err(ApplyAndStoreError::State)?;
            } else {
                log::debug!("Deleting state for projection: {:?}", id);
                storage
                    .delete_state(id)
                    .await
                    .map_err(ApplyAndStoreError::State)?;
            }
        }
        Ok(())
    }
    /// Returns the ID of the stream from the given event.
    fn get_id_from_event(&self, event: &Event<Self::EventType>) -> Uuid {
        event.stream_id
    }
}

/// A wrapper type that provides an [`EventObserver`] implementation for [`Projection`] types.
///
/// This wrapper is used to subscribe projections to an event bus.
///
/// # Example
///
/// ```ignore
/// use epoch_core::projection::ProjectionHandler;
///
/// let projection = MyProjection::new();
/// let handler = ProjectionHandler::new(projection);
/// event_bus.subscribe(handler).await?;
/// ```
pub struct ProjectionHandler<P>(pub P);

impl<P> ProjectionHandler<P> {
    /// Creates a new `ProjectionHandler` wrapping the given projection.
    pub fn new(projection: P) -> Self {
        Self(projection)
    }

    /// Returns a reference to the inner projection.
    pub fn inner(&self) -> &P {
        &self.0
    }

    /// Consumes the handler and returns the inner projection.
    pub fn into_inner(self) -> P {
        self.0
    }
}

#[async_trait]
impl<ED, P> EventObserver<ED> for ProjectionHandler<P>
where
    ED: EventData + Send + Sync + 'static,
    P: Projection<ED> + Send + Sync,
{
    fn subscriber_id(&self) -> &str {
        Projection::subscriber_id(&self.0)
    }

    async fn on_event(
        &self,
        event: Arc<Event<ED>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        self.0.apply_and_store(&event).await?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::event::EnumConversionError;
    use crate::state_store::StateStoreBackend;

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
    enum TestEventData {
        TestEvent { value: String },
    }

    impl EventData for TestEventData {
        fn event_type(&self) -> &'static str {
            match self {
                TestEventData::TestEvent { .. } => "TestEvent",
            }
        }
    }

    impl TryFrom<&TestEventData> for TestEventData {
        type Error = EnumConversionError;

        fn try_from(value: &TestEventData) -> Result<Self, Self::Error> {
            Ok(value.clone())
        }
    }

    #[derive(Debug, Clone, serde::Serialize)]
    struct TestState {
        id: Uuid,
    }

    impl ProjectionState for TestState {
        fn get_id(&self) -> Uuid {
            self.id
        }
    }

    #[derive(Debug, thiserror::Error)]
    enum TestStateStoreError {}

    #[derive(Debug, Clone)]
    struct TestStateStore;

    #[async_trait]
    impl StateStoreBackend<TestState> for TestStateStore {
        type Error = TestStateStoreError;

        async fn get_state(&self, _id: Uuid) -> Result<Option<TestState>, Self::Error> {
            Ok(None)
        }

        async fn persist_state(&mut self, _id: Uuid, _state: TestState) -> Result<(), Self::Error> {
            Ok(())
        }

        async fn delete_state(&mut self, _id: Uuid) -> Result<(), Self::Error> {
            Ok(())
        }
    }

    #[derive(Debug, thiserror::Error)]
    enum TestProjectionError {}

    struct TestProjection;

    #[async_trait]
    impl Projection<TestEventData> for TestProjection {
        type State = TestState;
        type StateStore = TestStateStore;
        type EventType = TestEventData;
        type ProjectionError = TestProjectionError;

        fn subscriber_id(&self) -> &str {
            "projection:test-projection"
        }

        fn get_state_store(&self) -> Self::StateStore {
            TestStateStore
        }

        fn apply(
            &self,
            _state: Option<Self::State>,
            event: &Event<Self::EventType>,
        ) -> Result<Option<Self::State>, Self::ProjectionError> {
            Ok(Some(TestState {
                id: event.stream_id,
            }))
        }
    }

    #[test]
    fn projection_subscriber_id_is_available_via_event_observer() {
        let projection = TestProjection;

        // Access subscriber_id via EventObserver trait using ProjectionHandler
        let handler = ProjectionHandler::new(projection);
        let observer: &dyn EventObserver<TestEventData> = &handler;
        assert_eq!(observer.subscriber_id(), "projection:test-projection");

        // Access subscriber_id via Projection trait directly
        assert_eq!(
            Projection::subscriber_id(handler.inner()),
            "projection:test-projection"
        );
    }
}
