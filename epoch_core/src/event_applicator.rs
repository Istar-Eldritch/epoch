//! Base trait for types that can apply events to build state.
//!
//! This module provides the [`EventApplicator`] trait, which captures the common behavior
//! between Aggregates and Projections: both need to apply events to state. However, they
//! differ in how they're used:
//!
//! - [`Aggregate`](crate::aggregate::Aggregate): Handles commands, persists state in `handle()`, publishes events
//! - [`Projection`](crate::projection::Projection): Subscribes to event bus, persists state in `apply_and_store()`
//!
//! # Why This Separation?
//!
//! Aggregates should NOT be subscribed to the event bus as projections. The `handle()` method
//! already persists state before publishing events. Subscribing an aggregate to the bus would
//! cause duplicate writes and race conditions.
//!
//! By having `Aggregate` extend `EventApplicator` (not `Projection`), we prevent
//! [`ProjectionHandler`](crate::projection::ProjectionHandler) from accepting aggregates,
//! providing compile-time safety against this anti-pattern.

use crate::event::{EnumConversionError, Event, EventData};
use crate::prelude::{EventStream, RefEventStream, StateStoreBackend};
use async_trait::async_trait;
use std::pin::Pin;
use tokio_stream::StreamExt;
use uuid::Uuid;

/// State built from events. Base trait for both projection and aggregate state.
///
/// This trait represents the current state derived from a sequence of events.
/// It is implemented by both projection state and aggregate state types.
pub trait EventApplicatorState {
    /// Returns the unique identifier of this state instance.
    ///
    /// This ID is used to retrieve and persist the state and to correlate
    /// events with their corresponding state.
    fn get_id(&self) -> &Uuid;
}

/// Errors that can arise during rehydration.
///
/// Rehydration is the process of reconstructing state by replaying events
/// from an event stream.
#[derive(Debug, thiserror::Error)]
pub enum ReHydrateError<E, S, ES> {
    /// Error applying an event to the state.
    #[error("Event application error: {0}")]
    Application(E),

    /// Error converting an event from the superset type to the subset type.
    ///
    /// This occurs when an event in the stream cannot be converted to the
    /// specific event type handled by this applicator.
    #[error("Error transforming event: {0}")]
    Subset(S),

    /// Error reading from the event stream.
    #[error("Error reading from event stream: {0}")]
    EventStream(ES),
}

/// Base trait for types that apply events to build/update state.
///
/// This trait captures the common behavior between Aggregates and Projections:
/// both need to apply events to state. However, they differ in how they're used:
///
/// - [`Aggregate`](crate::aggregate::Aggregate): Handles commands, persists state in `handle()`, publishes events
/// - [`Projection`](crate::projection::Projection): Subscribes to event bus, persists state in `apply_and_store()`
///
/// # Type Parameters
///
/// * `ED` - The superset event data type (e.g., `ApplicationEvent`)
///
/// # Associated Types
///
/// * `State` - The state type managed by this applicator
/// * `StateStore` - The backend for persisting state
/// * `EventType` - The subset event type this applicator handles
/// * `ApplyError` - Error type for event application
///
/// # Example
///
/// ```ignore
/// use epoch_core::prelude::*;
///
/// struct UserState {
///     id: Uuid,
///     name: String,
/// }
///
/// impl EventApplicatorState for UserState {
///     fn get_id(&self) -> &Uuid { &self.id }
/// }
///
/// struct UserProjection { /* ... */ }
///
/// impl EventApplicator<ApplicationEvent> for UserProjection {
///     type State = UserState;
///     type StateStore = InMemoryStateStore<UserState>;
///     type EventType = UserEvent;
///     type ApplyError = UserApplyError;
///
///     fn apply(&self, state: Option<Self::State>, event: &Event<Self::EventType>)
///         -> Result<Option<Self::State>, Self::ApplyError>
///     {
///         // Apply event to state...
///     }
///
///     fn get_state_store(&self) -> Self::StateStore {
///         // Return state store...
///     }
/// }
/// ```
#[async_trait]
pub trait EventApplicator<ED>
where
    ED: EventData + Send + Sync + 'static,
{
    /// The type of state managed by this applicator.
    type State: EventApplicatorState + Send + Sync + Clone;

    /// The state store backend for persisting state.
    type StateStore: StateStoreBackend<Self::State> + Send + Sync;

    /// The subset event type this applicator handles.
    ///
    /// Must implement `TryFrom<&ED, Error = EnumConversionError>` for efficient
    /// reference-based conversion. This is automatically generated by the `#[subset_enum]` macro.
    type EventType: EventData + for<'a> TryFrom<&'a ED, Error = EnumConversionError>;

    /// Error type for event application.
    type ApplyError: std::error::Error + Send + Sync + 'static;

    /// Applies an event to produce new state.
    ///
    /// This method contains the core business logic for updating state based on events.
    ///
    /// # Arguments
    ///
    /// * `state` - The current state, or `None` if no state exists yet
    /// * `event` - The event to apply
    ///
    /// # Returns
    ///
    /// * `Ok(Some(state))` - The new state after applying the event
    /// * `Ok(None)` - Indicates the state should be deleted
    /// * `Err(e)` - An error occurred during event application
    fn apply(
        &self,
        state: Option<Self::State>,
        event: &Event<Self::EventType>,
    ) -> Result<Option<Self::State>, Self::ApplyError>;

    /// Returns the state store for this applicator.
    fn get_state_store(&self) -> Self::StateStore;

    /// Extracts the state ID from an event.
    ///
    /// By default, returns the event's `stream_id`. Override this method if
    /// your state ID should be derived differently (e.g., from event data).
    fn get_id_from_event(&self, event: &Event<Self::EventType>) -> Uuid {
        event.stream_id
    }

    /// Reconstructs state from an event stream.
    ///
    /// This method replays events from the stream, applying each one to build
    /// up the final state. This is used for:
    /// - Loading state from the event store
    /// - Catching up on missed events
    /// - Re-building state after recovery
    ///
    /// # Type Parameters
    ///
    /// * `E` - The error type that can be returned by the stream
    ///
    /// # Arguments
    ///
    /// * `state` - The initial state to start from, or `None` for a fresh state
    /// * `event_stream` - The stream of events to replay
    ///
    /// # Returns
    ///
    /// The final state after applying all events, or an error if event
    /// application or stream reading fails.
    async fn re_hydrate<'a, E>(
        &self,
        mut state: Option<Self::State>,
        mut event_stream: Pin<Box<dyn EventStream<ED, E> + Send + 'a>>,
    ) -> Result<Option<Self::State>, ReHydrateError<Self::ApplyError, EnumConversionError, E>> {
        while let Some(event) = event_stream.next().await {
            let event = event.map_err(ReHydrateError::EventStream)?;
            let event = event
                .to_subset_event_ref()
                .map_err(ReHydrateError::Subset)?;
            state = self
                .apply(state, &event)
                .map_err(ReHydrateError::Application)?;
        }

        Ok(state)
    }

    /// Reconstructs state from a reference-based event stream.
    ///
    /// This is an optimized version of [`re_hydrate`](Self::re_hydrate) that accepts
    /// a stream of event references rather than owned events. This avoids cloning
    /// events when re-hydrating from a local slice (e.g., in [`Aggregate::handle`](crate::aggregate::Aggregate::handle)).
    ///
    /// # Type Parameters
    ///
    /// * `'a` - The lifetime of the event references in the stream
    /// * `E` - The error type that can be returned by the stream
    ///
    /// # Arguments
    ///
    /// * `state` - The initial state to start re-hydration from, or `None` for a fresh state
    /// * `event_stream` - A pinned reference-based event stream
    ///
    /// # Returns
    ///
    /// The re-hydrated state after applying all events from the stream, or an error if
    /// event application or stream reading fails.
    async fn re_hydrate_from_refs<'a, E>(
        &self,
        mut state: Option<Self::State>,
        mut event_stream: Pin<Box<dyn RefEventStream<'a, ED, E> + Send + 'a>>,
    ) -> Result<Option<Self::State>, ReHydrateError<Self::ApplyError, EnumConversionError, E>>
    where
        E: 'a,
    {
        while let Some(event) = event_stream.next().await {
            let event = event.map_err(ReHydrateError::EventStream)?;
            let event = event
                .to_subset_event_ref()
                .map_err(ReHydrateError::Subset)?;
            state = self
                .apply(state, &event)
                .map_err(ReHydrateError::Application)?;
        }

        Ok(state)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::state_store::StateStoreBackend;

    // Test event data
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
    enum TestEventData {
        Created { name: String },
        Updated { name: String },
    }

    impl EventData for TestEventData {
        fn event_type(&self) -> &'static str {
            match self {
                TestEventData::Created { .. } => "Created",
                TestEventData::Updated { .. } => "Updated",
            }
        }
    }

    impl TryFrom<&TestEventData> for TestEventData {
        type Error = EnumConversionError;

        fn try_from(value: &TestEventData) -> Result<Self, Self::Error> {
            Ok(value.clone())
        }
    }

    // Test state
    #[derive(Debug, Clone)]
    struct TestState {
        id: Uuid,
        name: String,
    }

    impl EventApplicatorState for TestState {
        fn get_id(&self) -> &Uuid {
            &self.id
        }
    }

    // Test state store
    #[derive(Debug, Clone)]
    struct TestStateStore;

    #[derive(Debug, thiserror::Error)]
    enum TestStateStoreError {}

    #[async_trait]
    impl StateStoreBackend<TestState> for TestStateStore {
        type Error = TestStateStoreError;

        async fn get_state(&self, _id: Uuid) -> Result<Option<TestState>, Self::Error> {
            Ok(None)
        }

        async fn persist_state(&mut self, _id: Uuid, _state: TestState) -> Result<(), Self::Error> {
            Ok(())
        }

        async fn delete_state(&mut self, _id: Uuid) -> Result<(), Self::Error> {
            Ok(())
        }
    }

    // Test applicator
    #[derive(Debug, thiserror::Error)]
    enum TestApplyError {
        #[error("Missing state for update")]
        MissingState,
    }

    struct TestApplicator;

    impl EventApplicator<TestEventData> for TestApplicator {
        type State = TestState;
        type StateStore = TestStateStore;
        type EventType = TestEventData;
        type ApplyError = TestApplyError;

        fn apply(
            &self,
            state: Option<Self::State>,
            event: &Event<Self::EventType>,
        ) -> Result<Option<Self::State>, Self::ApplyError> {
            match event.data.as_ref().unwrap() {
                TestEventData::Created { name } => Ok(Some(TestState {
                    id: event.stream_id,
                    name: name.clone(),
                })),
                TestEventData::Updated { name } => {
                    let mut state = state.ok_or(TestApplyError::MissingState)?;
                    state.name = name.clone();
                    Ok(Some(state))
                }
            }
        }

        fn get_state_store(&self) -> Self::StateStore {
            TestStateStore
        }
    }

    #[test]
    fn event_applicator_state_returns_id() {
        let id = Uuid::new_v4();
        let state = TestState {
            id,
            name: "test".to_string(),
        };
        assert_eq!(state.get_id(), &id);
    }

    #[test]
    fn event_applicator_apply_creates_state() {
        let applicator = TestApplicator;
        let stream_id = Uuid::new_v4();

        let event = Event::<TestEventData>::builder()
            .stream_id(stream_id)
            .stream_version(1)
            .event_type("Created".to_string())
            .data(Some(TestEventData::Created {
                name: "Test".to_string(),
            }))
            .build()
            .unwrap();

        let result = applicator.apply(None, &event).unwrap();
        assert!(result.is_some());
        let state = result.unwrap();
        assert_eq!(state.id, stream_id);
        assert_eq!(state.name, "Test");
    }

    #[test]
    fn event_applicator_apply_updates_state() {
        let applicator = TestApplicator;
        let stream_id = Uuid::new_v4();

        let initial_state = TestState {
            id: stream_id,
            name: "Initial".to_string(),
        };

        let event = Event::<TestEventData>::builder()
            .stream_id(stream_id)
            .stream_version(2)
            .event_type("Updated".to_string())
            .data(Some(TestEventData::Updated {
                name: "Updated".to_string(),
            }))
            .build()
            .unwrap();

        let result = applicator.apply(Some(initial_state), &event).unwrap();
        assert!(result.is_some());
        let state = result.unwrap();
        assert_eq!(state.name, "Updated");
    }

    #[test]
    fn event_applicator_get_id_from_event_returns_stream_id() {
        let applicator = TestApplicator;
        let stream_id = Uuid::new_v4();

        let event = Event::<TestEventData>::builder()
            .stream_id(stream_id)
            .stream_version(1)
            .event_type("Created".to_string())
            .data(Some(TestEventData::Created {
                name: "Test".to_string(),
            }))
            .build()
            .unwrap();

        assert_eq!(applicator.get_id_from_event(&event), stream_id);
    }
}
