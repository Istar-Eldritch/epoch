//! Base trait for types that can apply events to build state.
//!
//! This module defines [`EventApplicator`], the foundational trait shared by both
//! [`Projection`](crate::projection::Projection) and [`Aggregate`](crate::aggregate::Aggregate).
//! It captures the common behavior of applying events to build or update state.

use crate::event::{EnumConversionError, Event, EventData};
use crate::event_store::{EventStream, RefEventStream};
use crate::state_store::StateStoreBackend;
use async_trait::async_trait;
use std::pin::Pin;
use tokio_stream::StreamExt;
use uuid::Uuid;

/// State built from events. Base trait for both projection and aggregate state.
///
/// This trait represents the minimal interface for state that can be managed
/// by an [`EventApplicator`]. Both projection state and aggregate state must
/// implement this trait.
pub trait EventApplicatorState {
    /// Returns the unique identifier of this state instance.
    fn get_id(&self) -> Uuid;
}

/// Errors that can arise during rehydration.
#[derive(Debug, thiserror::Error)]
pub enum ReHydrateError<E, S, ES> {
    /// Error applying an event
    #[error("Event application error: {0}")]
    Application(E),
    /// Error converting event to subset type
    #[error("Error transforming event: {0}")]
    Subset(S),
    /// Error reading from event stream
    #[error("Error reading from event stream: {0}")]
    EventStream(ES),
}

/// Base trait for types that apply events to build/update state.
///
/// This trait captures the common behavior between Aggregates and Projections:
/// both need to apply events to state. However, they differ in how they're used:
/// - [`Aggregate`](crate::aggregate::Aggregate): Handles commands, persists state in `handle()`, publishes events
/// - [`Projection`](crate::projection::Projection): Subscribes to event bus, persists state in `apply_and_store()`
///
/// # Type Parameters
///
/// * `ED` - The "envelope" event data type (typically an application-wide enum of all events)
#[async_trait]
pub trait EventApplicator<ED>
where
    ED: EventData + Send + Sync + 'static,
{
    /// The type of state managed by this applicator.
    type State: EventApplicatorState + Send + Sync + Clone;

    /// The state store backend for persisting state.
    type StateStore: StateStoreBackend<Self::State> + Send + Sync;

    /// The subset event type this applicator handles.
    ///
    /// Must implement `TryFrom<&ED, Error = EnumConversionError>` for efficient
    /// reference-based conversion. This is automatically generated by the `#[subset_enum]` macro.
    type EventType: EventData + for<'a> TryFrom<&'a ED, Error = EnumConversionError>;

    /// Error type for event application.
    type ApplyError: std::error::Error + Send + Sync + 'static;

    /// Applies an event to produce new state.
    ///
    /// Returns `None` to indicate the state should be deleted.
    ///
    /// # Arguments
    ///
    /// * `state` - The current state, or `None` if no state exists yet
    /// * `event` - The event to apply
    ///
    /// # Returns
    ///
    /// * `Ok(Some(state))` - The new state after applying the event
    /// * `Ok(None)` - The state should be deleted
    /// * `Err(e)` - An error occurred while applying the event
    fn apply(
        &self,
        state: Option<Self::State>,
        event: &Event<Self::EventType>,
    ) -> Result<Option<Self::State>, Self::ApplyError>;

    /// Returns the state store.
    fn get_state_store(&self) -> Self::StateStore;

    /// Extracts the state ID from an event.
    ///
    /// The default implementation returns the event's `stream_id`.
    fn get_id_from_event(&self, event: &Event<Self::EventType>) -> Uuid {
        event.stream_id
    }

    /// Reconstructs state from an event stream.
    ///
    /// This method replays events from the stream, applying each one to build
    /// up the final state.
    ///
    /// # Type Parameters
    ///
    /// * `'a` - The lifetime of the event stream
    /// * `E` - The error type that can be returned by the stream
    ///
    /// # Arguments
    ///
    /// * `state` - The initial state to start from, or `None` for a fresh state
    /// * `event_stream` - The stream of events to replay
    ///
    /// # Returns
    ///
    /// The final state after applying all events, or an error if any step fails.
    async fn re_hydrate<'a, E>(
        &self,
        mut state: Option<Self::State>,
        mut event_stream: Pin<Box<dyn EventStream<ED, E> + Send + 'a>>,
    ) -> Result<Option<Self::State>, ReHydrateError<Self::ApplyError, EnumConversionError, E>> {
        while let Some(event) = event_stream.next().await {
            let event = event.map_err(ReHydrateError::EventStream)?;
            let event = event
                .to_subset_event_ref()
                .map_err(ReHydrateError::Subset)?;
            state = self
                .apply(state, &event)
                .map_err(ReHydrateError::Application)?;
        }
        Ok(state)
    }

    /// Reconstructs state from an event stream, stopping before a specified version.
    ///
    /// This is used by projections to re-hydrate state up to (but not including) the
    /// event being processed, to avoid applying the same event twice.
    ///
    /// # Type Parameters
    ///
    /// * `'a` - The lifetime of the event stream
    /// * `E` - The error type that can be returned by the stream
    ///
    /// # Arguments
    ///
    /// * `state` - The initial state to start from, or `None` for a fresh state
    /// * `event_stream` - The stream of events to replay
    /// * `stop_before_version` - Stop processing when reaching this version
    ///
    /// # Returns
    ///
    /// The final state after applying all events before the specified version.
    async fn re_hydrate_until<'a, E>(
        &self,
        mut state: Option<Self::State>,
        mut event_stream: Pin<Box<dyn EventStream<ED, E> + Send + 'a>>,
        stop_before_version: u64,
    ) -> Result<Option<Self::State>, ReHydrateError<Self::ApplyError, EnumConversionError, E>> {
        while let Some(event) = event_stream.next().await {
            let event = event.map_err(ReHydrateError::EventStream)?;
            // Stop if we've reached the version we should stop before
            if event.stream_version >= stop_before_version {
                break;
            }
            let event = event
                .to_subset_event_ref()
                .map_err(ReHydrateError::Subset)?;
            state = self
                .apply(state, &event)
                .map_err(ReHydrateError::Application)?;
        }
        Ok(state)
    }

    /// Reconstructs state from a reference-based event stream.
    ///
    /// This is an optimized version of [`re_hydrate`](Self::re_hydrate) that accepts
    /// a stream of event references rather than owned events. This avoids cloning
    /// events when re-hydrating from a local slice (e.g., in [`Aggregate::handle`](crate::aggregate::Aggregate::handle)).
    ///
    /// # Type Parameters
    ///
    /// * `'a` - The lifetime of the event references in the stream
    /// * `E` - The error type that can be returned by the stream
    ///
    /// # Arguments
    ///
    /// * `state` - The initial state to start from, or `None` for a fresh state
    /// * `event_stream` - A pinned reference-based event stream
    ///
    /// # Returns
    ///
    /// The final state after applying all events, or an error if any step fails.
    async fn re_hydrate_from_refs<'a, E>(
        &self,
        mut state: Option<Self::State>,
        mut event_stream: Pin<Box<dyn RefEventStream<'a, ED, E> + Send + 'a>>,
    ) -> Result<Option<Self::State>, ReHydrateError<Self::ApplyError, EnumConversionError, E>>
    where
        E: 'a,
    {
        while let Some(event) = event_stream.next().await {
            let event = event.map_err(ReHydrateError::EventStream)?;
            let event = event
                .to_subset_event_ref()
                .map_err(ReHydrateError::Subset)?;
            state = self
                .apply(state, &event)
                .map_err(ReHydrateError::Application)?;
        }
        Ok(state)
    }
}
