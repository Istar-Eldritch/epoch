# Specification: Event Correlation and Causation Tracking

**Document ID:** 2602121055  
**Status:** Draft  
**Created:** 2026-02-12  
**Author:** AI Agent  

---

## 1. Problem Statement

When a user places an order and a saga coordinates inventory reservation, payment processing, and order confirmation across three aggregates, there is no way to query "show me everything that happened because of this order" or "what specifically caused this payment event." Events are isolated in their individual streams with no metadata linking them.

Today, Epoch's `Event` struct has no concept of *why* an event was produced or *what other events* it's related to. The `Command` struct carries no context about what triggered it. The `EventStoreBackend` trait only supports querying by `stream_id` — there is no cross-stream query capability.

This makes debugging, auditing, and process tracing impossible at the framework level.

## 2. Proposed Solution

Add `correlation_id` and `causation_id` metadata to both `Command` and `Event`, with automatic propagation through `Aggregate::handle()`, ergonomic helpers for sagas, and query APIs on `EventStoreBackend`.

### 2.1 Causation Semantics

- **`causation_id: Option<Uuid>`** — Points to the specific event that directly caused this event. For user-triggered commands, this is `None`. When a saga reacts to event A and dispatches a command that produces event B, then `B.causation_id = Some(A.id)`. Forms a parent→child chain.

- **`correlation_id: Option<Uuid>`** — A shared group identifier tying together the entire causal tree rooted at the original user action. Auto-generated from the first event's `id` if not explicitly provided. All downstream events inherit the same `correlation_id`.

### 2.2 Propagation Model — Semi-Automatic

- **Inside `Aggregate::handle()`**: Fully automatic. The framework stamps `correlation_id` and `causation_id` from the command onto all events produced by `handle_command()`. If no `correlation_id` is on the command, one is auto-generated from the first event's `id`.

- **At the saga boundary**: Explicit via ergonomic helper. Sagas use `Command::new(...).caused_by(&event)` to thread causation context when dispatching commands. This keeps the `Saga::handle_event` signature unchanged and avoids hidden global state.

### 2.3 Query Model

Two new required methods on `EventStoreBackend`:

- **`read_events_by_correlation_id(correlation_id)`** — Returns all events sharing a correlation ID, ordered by `global_sequence`. Answers "show me everything that happened because of this user action."

- **`trace_causation_chain(event_id)`** — Returns the ancestors, the event itself, and all descendants in the causal subtree — *excluding* unrelated branches that merely share the same `correlation_id`. Answers "what specifically led to and followed from this event."

Both return `Vec<Event<Self::EventType>>` (not streams), since correlation groups are bounded and small (typically 5-50 events).

`trace_causation_chain` is implemented by fetching all events for the correlation group in a single query, then filtering the causal subtree in a shared Rust utility. This is faster than multiple sequential database round-trips for walking the tree.

## 3. Changes

### 3.1 `Event` Struct — `epoch_core/src/event.rs`

Add two new fields:

```rust
pub struct Event<D: EventData> {
    // ... existing fields ...

    /// The ID of the event that directly caused this event to be produced.
    ///
    /// `None` for events triggered by direct user commands (no prior event in the chain).
    /// `Some(event_id)` when this event was produced as a consequence of another event
    /// (e.g., via a saga reacting to an event and dispatching a command).
    pub causation_id: Option<Uuid>,

    /// A shared identifier tying together all events in a causal tree.
    ///
    /// All events originating from the same user action share the same `correlation_id`.
    /// Auto-generated by `Aggregate::handle()` if not provided on the command.
    /// `None` for events that predate causation tracking.
    pub correlation_id: Option<Uuid>,
}
```

**Update `EventBuilder`:**
- Add `correlation_id: Option<Uuid>` and `causation_id: Option<Uuid>` fields
- Add `.correlation_id(id: Uuid)` and `.causation_id(id: Uuid)` builder methods
- Include in `new()` (default `None`), `build()`, `data()` (type-changing builder), `Default`
- Include in `From<Event<D>> for EventBuilder<D>`

**Update all `Event { ... }` construction sites to include new fields:**
- `to_subset_event` — copy `correlation_id`, `causation_id`
- `to_subset_event_ref` — copy `correlation_id`, `causation_id`
- `to_superset_event` — copy `correlation_id`, `causation_id`

### 3.2 `Command` Struct — `epoch_core/src/aggregate.rs`

Add two new fields and builder methods:

```rust
pub struct Command<D, C> {
    // ... existing fields ...

    /// The ID of the event that caused this command to be dispatched.
    pub causation_id: Option<Uuid>,

    /// The correlation ID to propagate to events produced by this command.
    pub correlation_id: Option<Uuid>,
}
```

**`Command::new()` unchanged** — new fields default to `None`:

```rust
pub fn new(aggregate_id: Uuid, data: D, credentials: Option<C>, aggregate_version: Option<u64>) -> Self {
    Command {
        aggregate_id, data, credentials, aggregate_version,
        causation_id: None,
        correlation_id: None,
    }
}
```

**New builder methods:**

```rust
/// Sets causation context from a triggering event.
///
/// Sets `causation_id = Some(event.id)` and inherits the event's `correlation_id`.
/// Use this in saga `handle_event` implementations to thread causal context.
pub fn caused_by<ED: EventData>(mut self, event: &Event<ED>) -> Self {
    self.causation_id = Some(event.id);
    self.correlation_id = event.correlation_id;
    self
}

/// Explicitly sets a correlation ID.
///
/// Use this at entry points (e.g., HTTP handlers) to inject an external
/// trace ID as the correlation ID for all downstream events.
pub fn with_correlation_id(mut self, correlation_id: Uuid) -> Self {
    self.correlation_id = Some(correlation_id);
    self
}
```

**Update `to_subset_command` and `to_superset_command`** to propagate both new fields.

### 3.3 Automatic Propagation — `epoch_core/src/aggregate.rs`

**`Aggregate::handle()`** (non-transactional, line ~352):

The existing `.map()` closure stamps `stream_version`. Add causation stamping:

```rust
// Resolve correlation_id before the iterator
let correlation_id = command.correlation_id;
let causation_id = command.causation_id;

let events: Vec<Event<ED>> = self
    .handle_command(&state, cmd)
    .await
    .map_err(HandleCommandError::Command)?
    .into_iter()
    .enumerate()
    .map(|(i, mut e)| {
        e.stream_version = new_state_version + i as u64;
        new_state_version = e.stream_version;

        // Stamp causation context
        e.causation_id = causation_id;
        if let Some(cid) = correlation_id {
            e.correlation_id = Some(cid);
        } else if i == 0 {
            e.correlation_id = Some(e.id);
        }
        // For events after index 0 without explicit correlation,
        // correlation_id is set after the first event is processed
        e
    })
    .collect();

// If correlation was auto-generated from event 0, backfill remaining events
if correlation_id.is_none() && events.len() > 1 {
    let auto_correlation = events[0].correlation_id;
    // events is mut, so we can update in-place — but it's collected already.
    // Alternative: use a two-pass approach or capture in a Cell.
}
```

**Note:** The auto-generation of `correlation_id` from the first event's `id` requires care since the events are generated in a single `.map()`. The implementation should either:
- Pre-generate the first event's `id` before the iterator, or
- Use a `let mut auto_correlation_id = None;` captured by the closure, set on the first iteration, and used for subsequent iterations

The same logic must be applied identically to **`AggregateTransaction::handle()`** (line ~800).

### 3.4 PostgreSQL Persistence — `epoch_pg`

**Migration `m007_add_causation_columns.rs`:**

```sql
-- Add nullable columns (no backfill needed — NULL means "predates tracking")
ALTER TABLE epoch_events ADD COLUMN IF NOT EXISTS correlation_id UUID;
ALTER TABLE epoch_events ADD COLUMN IF NOT EXISTS causation_id UUID;

-- Index for cross-stream correlation queries
CREATE INDEX IF NOT EXISTS idx_epoch_events_correlation_id ON epoch_events(correlation_id);

-- Update the NOTIFY trigger function to include new fields
CREATE OR REPLACE FUNCTION epoch_notify_event()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify(
        TG_ARGV[0],
        json_build_object(
            'id', NEW.id,
            'stream_id', NEW.stream_id,
            'stream_version', NEW.stream_version,
            'event_type', NEW.event_type,
            'actor_id', NEW.actor_id,
            'purger_id', NEW.purger_id,
            'data', NEW.data,
            'created_at', NEW.created_at,
            'purged_at', NEW.purged_at,
            'global_sequence', NEW.global_sequence,
            'correlation_id', NEW.correlation_id,
            'causation_id', NEW.causation_id
        )::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

No `causation_id` index — `trace_causation_chain` uses correlation fetch + Rust filtering.

**`PgDBEvent` struct** (`epoch_pg/src/event_store.rs`):

Add:
```rust
#[sqlx(default)]
pub correlation_id: Option<Uuid>,
#[sqlx(default)]
pub causation_id: Option<Uuid>,
```

**Update all `INSERT INTO epoch_events` statements** (in `store_event` and `store_events_in_tx`) to include `correlation_id` and `causation_id` columns and bind values.

**Update all `SELECT` column lists** in `read_events_since` to include the new columns.

**Update all `Event { ... }` construction sites** (5+ locations across `event_store.rs` and `event_bus/mod.rs`) to populate `correlation_id` and `causation_id` from `PgDBEvent`/`row` fields.

These sites are:
1. `PgEventStore::store_events_in_tx` — stored event construction (~line 103)
2. `PgEventStore::store_event` — event with sequence (~line 336)
3. `PgEventBus::read_all_events_since` — catch-up read (~line 211)
4. `PgEventBus` real-time listener — NOTIFY deserialization (~line 468)
5. `PgEventBus` catch-up listener during startup — NOTIFY buffer (~line 1116)
6. `PgEventBus` catch-up replay — row construction (~line 1228)

### 3.5 In-Memory Store Updates — `epoch_mem/src/event_store.rs`

**Add secondary index to `EventStoreData`:**

```rust
struct EventStoreData<D: EventData> {
    events: HashMap<Uuid, Arc<Event<D>>>,
    stream_events: HashMap<Uuid, Vec<Uuid>>,
    stream_version: HashMap<Uuid, u64>,
    correlation_events: HashMap<Uuid, Vec<Uuid>>,  // NEW
}
```

**Update `store_event` and `store_events`** to maintain the `correlation_events` index when an event has `Some(correlation_id)`.

### 3.6 Query API — `epoch_core/src/event_store.rs`

Add to `EventStoreBackend` trait (required methods, no defaults):

```rust
/// Returns all events sharing the given correlation ID, ordered by global_sequence.
async fn read_events_by_correlation_id(
    &self,
    correlation_id: Uuid,
) -> Result<Vec<Event<Self::EventType>>, Self::Error>;

/// Returns the causal subtree for the given event: its ancestors, the event
/// itself, and all descendants — excluding unrelated branches that share
/// the same correlation ID but are not in the direct causal path.
///
/// Events are ordered by global_sequence.
async fn trace_causation_chain(
    &self,
    event_id: Uuid,
) -> Result<Vec<Event<Self::EventType>>, Self::Error>;
```

### 3.7 Shared Causation Tree Utility — `epoch_core`

A new module or function (could live in `event.rs` or a new `causation.rs`):

```rust
/// Extracts the causal subtree from a set of correlated events.
///
/// Given all events sharing a correlation ID and a target event ID, returns:
/// - All ancestors (walking up via causation_id)
/// - The target event itself
/// - All descendants (walking down — events whose causation_id is in the set)
///
/// Events are returned ordered by global_sequence.
pub fn extract_causation_subtree<D: EventData>(
    events: Vec<Event<D>>,
    target_event_id: Uuid,
) -> Vec<Event<D>>
```

Implementation:
1. Build a `HashMap<Uuid, &Event>` for O(1) lookups
2. Walk up from `target_event_id` via `causation_id` to collect ancestor IDs
3. Walk down: starting from `target_event_id`, iteratively find all events whose `causation_id` is in the collected set (BFS/DFS)
4. Collect the union, sort by `global_sequence`

### 3.8 Backend Implementations

**PG `read_events_by_correlation_id`:**
```sql
SELECT id, stream_id, stream_version, event_type, data, created_at,
       actor_id, purger_id, purged_at, global_sequence,
       correlation_id, causation_id
FROM epoch_events
WHERE correlation_id = $1
ORDER BY global_sequence ASC
```

**PG `trace_causation_chain`:**
1. `SELECT ... FROM epoch_events WHERE id = $1` to get the starting event
2. If `correlation_id` is `None`, return just that event
3. Call `read_events_by_correlation_id(correlation_id)`
4. Apply `extract_causation_subtree(events, event_id)`

**In-memory `read_events_by_correlation_id`:**
- Look up `correlation_events[correlation_id]` for event IDs
- Collect events, sort by `global_sequence`

**In-memory `trace_causation_chain`:**
- Look up event by ID from `events` map
- If `correlation_id` is `None`, return just that event
- Call `read_events_by_correlation_id(correlation_id)`
- Apply `extract_causation_subtree(events, event_id)`

### 3.9 Example Updates

Update `epoch/examples/saga-order-fulfillment.rs`:
- Add `.caused_by(&event)` to all `Command::new()` calls inside the saga's `handle_event`
- After the workflow completes, demonstrate:
  - `read_events_by_correlation_id` to show all correlated events
  - `trace_causation_chain` on a mid-chain event to show the filtered subtree

## 4. Backward Compatibility

- **`Command::new()` signature unchanged** — 4 positional args, new fields default to `None`
- **All existing `Event { ... }` test code** needs the new fields — but they're `Option<Uuid>` defaulting to `None`, so existing tests just add two `None` fields (or use the builder)
- **Existing PG databases** — nullable columns, no backfill. `NULL` means "predates tracking"
- **`EventStoreBackend` trait** gains two new required methods — both implementations (`PgEventStore`, `InMemoryEventStore`) are in this repository. No external implementors to break.

## 5. Files Modified

| Crate | File | Changes |
|-------|------|---------|
| `epoch_core` | `src/event.rs` | Add fields to `Event`, `EventBuilder`; update conversions; add builder methods |
| `epoch_core` | `src/aggregate.rs` | Add fields to `Command`; add `caused_by()`, `with_correlation_id()`; update `to_subset_command`/`to_superset_command`; stamp causation in `handle()` and `AggregateTransaction::handle()` |
| `epoch_core` | `src/event_store.rs` | Add `read_events_by_correlation_id` and `trace_causation_chain` to trait |
| `epoch_core` | `src/causation.rs` *(new)* | `extract_causation_subtree` utility function |
| `epoch_core` | `src/lib.rs` | Export new module |
| `epoch_pg` | `src/event_store.rs` | Update `PgDBEvent`, INSERT statements, SELECT column lists, `Event` construction |
| `epoch_pg` | `src/event_bus/mod.rs` | Update 3+ `Event` construction sites to include new fields |
| `epoch_pg` | `src/migrations/m007_add_causation_columns.rs` *(new)* | Migration for columns, index, trigger update |
| `epoch_pg` | `src/migrations/mod.rs` | Register m007 |
| `epoch_mem` | `src/event_store.rs` | Add `correlation_events` index; implement query methods |
| `epoch` | `examples/saga-order-fulfillment.rs` | Add `.caused_by()` usage; demonstrate query APIs |

## 6. Testing Strategy

**Unit tests:**
- `Event` field propagation through all conversion methods
- `Command::caused_by()` and `.with_correlation_id()` behavior
- `extract_causation_subtree` with: linear chain, branching tree, multi-saga branches, single event with no causation
- Auto-generation of `correlation_id` when command has none

**Integration tests:**
- Full saga workflow producing events across 3 aggregates, verifying correlation/causation IDs are set correctly on all events
- `read_events_by_correlation_id` returns complete correlated group
- `trace_causation_chain` on mid-chain event excludes unrelated branches
- Events with `None` causation fields (pre-tracking) handled gracefully

**PG-specific tests:**
- Migration runs on existing databases
- NOTIFY payload includes new fields
- Round-trip: store event with causation → read back → fields preserved

**Backward compatibility:**
- All existing tests pass without modification (modulo adding `None` fields to struct literals)
